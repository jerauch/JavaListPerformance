<!DOCTYPE html>
<html>
<head>
<title>readme.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="les-list-en-java-et-leur-performance">Les List en java et leur performance</h1>
<p>Dans cet article nous allons revenir aux base du langage Java. J'ai passé plusieurs entretiens d'embauches techniques et j'ai été très étonné quand on m'a posé des questions sur les bases du langage, et plus précisément sur le package Collection, les List et les implémentations.</p>
<p>Qu'est ce qu'une List ? Voyons la définition de la javadoc :</p>
<p><em>An ordered collection (also known as a sequence). The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list.
Unlike sets, lists typically allow duplicate elements.</em></p>
<p>Une liste nous permet de stocker des éléments tout en conservant l'ordre de ces éléments.</p>
<p>Différentes implémentations sont proposées :</p>
<ul>
<li>Vector : La liste est implémentée sous forme de tableau, et l'implémentation est thread-safe</li>
<li>ArrayList : La liste est implémentée sous forme de tableau</li>
<li>LinkedList : La liste est consistée d'éléments liées entre eux, comme des maillons d'une chaine</li>
<li>CopyOnWriteArrayList : La liste est implémentée sous forme de tableau et chaque ajout à la liste va provoquer une copie vers un nouveau tableau.</li>
</ul>
<p>J'ai toujours eu l'habitude d'utiliser des ArrayList, mais selon le type d'utilisation de la List il sera dpeut être plus efficace d'utiliser une autre implémentation.</p>
<p>Voyons les performances de ces différentes implémentation pour les fonctions add, get, size et iterator.</p>
<h2 id="add">Add</h2>
<p>Nous allons ajouter 10000 éléments dans chacune de nos 4 implémentations de liste, et lancer les traitement 100 fois pour calculer une moyenne.</p>
<pre class="hljs"><code><div>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
		liste.add(<span class="hljs-string">"Ma chaine "</span> + i);	
	}
</div></code></pre>
<p>Voilà les résultats :</p>
<p><img src="img/1.png" alt="alt text"></p>
<p>On constate que les performances sont assez identiques pour les implémentations Vector, ArrayList et LinkedList. L'implémentation Vector est synchronisée et threadsafe alors que les deux autres implémentations ne le sont pas, ce qui explique un léger impact sur les performances.</p>
<p>CopyOnWriteArrayList a des performances catastrophiques, comme on peut s'y attendre, cela s'explique par son implémentation :</p>
<p><em>A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.</em></p>
<p>Conclusion :</p>
<ul>
<li>Si votre code n'est pas utilisé dans un environnement multi thread, alors autant utiliser l'ArrayList. Sinon, privilégier le Vector.</li>
<li>On voit aussi que notre code est très dépendant de l'implémentation que nous allons utiliser : Un même code peut etre 3 x moins performant si on utilise une implémentation mal adaptée</li>
</ul>
<h2 id="get">Get</h2>
<p>Voyons comment se comportent nos implémentations pour récupérer les éléments aléatoirement dans notre liste :</p>
<pre class="hljs"><code><div>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
		liste.get(Random(<span class="hljs-number">0</span>, TAILLE_LISTE));	
	}
</div></code></pre>
<p><img src="img/2.png" alt="alt text"></p>
<p>Ici nous voyons que l'implémentation la plus lente est la LinkedList, ce qui est assez logique : Pour les 3 autres implémentations, les données sont stockées sous forme de tableau et il est donc possible d'accéder directement à l'élément. Pour une LinkedList, chaque élément est lié à l'élément précédant et suivant, si on veut accedéer à l'élément 50 de la liste, on devra parcourir les 49 premiers éléments...</p>
<p>Conclusion :</p>
<ul>
<li>Si l'accès à notre liste se fait aléatoirement, alors il faut absolument éviter d'utiliser une LinkedList.</li>
<li>Si les ajouts dans la liste sont toujours réalisés à la fin, alors privilégier le Vector ou l'ArrayList. En effet, pour une List de taille 10, si on ajoute un élément en position 5, il faudra décaller tous les éléments suivants. Dans une LinkedList il suffit d'ajouter une référence vers l'élément précédant et suivant.</li>
</ul>
<h2 id="size">Size</h2>
<p>Dans ce test nous allons voir les performances du calcul de la taille de la List :</p>
<pre class="hljs"><code><div>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
		liste.size(Random(<span class="hljs-number">0</span>, TAILLE_LISTE));	
	}
</div></code></pre>
<p><img src="img/3.png" alt="alt text"></p>
<p>Ici rien à dire les temps sont négligeables, bien que la représentation graphique puisse nous faire penser le contraire les temps sont négligeables.</p>
<h2 id="iterator">Iterator</h2>
<p>Et si on parcours tous les éléments de la List ?</p>
<p><img src="img/4.png" alt="alt text"></p>
<p>Idem, les temps sont sensiblement identiques.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Comme nous l'avons vu, il est très interessant de comprendre le fonctionnement des implémentations proposées par JAVA.</p>
<p>Si votre code est utilisé dans un environnement concurent, alors il faudra utiliser Vector ou CopyOnWriteArrayList.
Si vous devez ajouter des éléments dans la List (pas uniquement à la fin), et que vous n'avez pas beaucoup d'accès à la liste : On choisit la LinkedList.
Si on fait autant d'ajout que de lectures aléatoires, alors choisir la LinkedList.</p>
<p>Comme les Vector et ArrayList stockent leur données dans un tableau, ce tableau a une taille figée. Deux inconvénients :</p>
<ul>
<li>Pour une liste de petite taille, le tableau sera bien trop grand et il est possible de préciser la taille de la liste lors de la création :</li>
</ul>
<pre class="hljs"><code><div>Vector(<span class="hljs-keyword">int</span> initialCapacity)
<span class="hljs-comment">//Constructs an empty vector with the specified initial capacity and with its capacity increment equal to zero.</span>
</div></code></pre>
<ul>
<li>Qu'est ce qu'il se passe si on dépasse la capacité initiale du tableau ? Dans ce cas l'implémentation va devoir créer un nouveau tableau ce qui est aussi couteux en performance. mais on peut aussi préciser de combien l'élément sera incrémenté le nouveau tableau :</li>
</ul>
<pre class="hljs"><code><div>Vector(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">int</span> capacityIncrement)
<span class="hljs-comment">//Constructs an empty vector with the specified initial capacity and capacity increment.</span>
</div></code></pre>
<p>La vraie conclusion de cet article :</p>
<p><img src="img/5.png" alt="alt text"></p>

</body>
</html>
